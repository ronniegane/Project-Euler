'''Project Euler Problem 101: Optimum Polynomial
If we are presented with the first k terms of a sequence it is
impossible to say with certainty the value of the next term,
as there are infinitely many polynomial functions that can model the sequence.

As an example, let us consider the sequence of cube numbers.
This is defined by the generating function, 
un = n**3: 1, 8, 27, 64, 125, 216, ...

Suppose we were only given the first two terms of this sequence.
Working on the principle that "simple is best" we should assume a
linear relationship and predict the next term to be 15 (common difference 7).
Even if we were presented with the first three terms, by the same principle
of simplicity, a quadratic relationship should be assumed.

We shall define OP(k, n) to be the nth term of the optimum polynomial
generating function for the first k terms of a sequence. It should be
clear that OP(k, n) will accurately generate the terms of the sequence
for n ≤ k, and potentially the first incorrect term (FIT) will be OP(k, k+1);
in which case we shall call it a bad OP (BOP).

As a basis, if we were only given the first term of sequence, it would be most
sensible to assume constancy; that is, for n ≥ 2, OP(1, n) = u1.

Hence we obtain the following OPs for the cubic sequence:

OP(1, n) = 1 = 1, 1, 1, 1, ...
OP(2, n) = 7n−6 =	1, 8, 15, ...
OP(3, n) = 6n2−11n+6 = 1, 8, 27, 58, ...
OP(4, n) = n3 = 1, 8, 27, 64, 125, ...
Clearly no BOPs exist for k ≥ 4.

By considering the sum of FITs generated by the BOPs (indicated in red above),
we obtain 1 + 15 + 58 = 74.

Consider the following tenth degree polynomial generating function:

un = 1 − n + n**2 − n**3 + n**4 − n**5 + n**6 − n**7 + n**8 − n**9 + n**10

Find the sum of FITs for the BOPs.'''

##def matMult(matA, matB): # defining our own matrix multiplication if we don't use numpy
##    outMatrix = [[matA[i]* for col in matB]

import numpy as np  # we will use numpy for array functions

# Tenth order polynomial will be fitted when k = 10
maxN = 10
# So we will try to make fitted polynomials for k from 1 to 9
# And we will require up to 10 terms to check against
realSequence = [1 - n + n**2 - n**3 + n**4 - n**5 + n**6 - n**7 + n**8 - n**9 + n**10 for n in range(1, maxN + 1)]
print(realSequence)

fitSum = 0
fullXArray = np.array([np.array([float(x) for x in range(1,maxN+1)])**b for b in range(maxN+1)])
print(fullXArray) # need to cast to floats to avoid integer overflow at 9**10

for k in range(1, maxN):
    subSeq = np.array(realSequence[:k]) # this is our y vector
    #print(subSeq)
    xCol = np.array(range(1,k+1))# this is our x-vector of numbers
    xArray = np.array([xCol**b for b in range(k)]) # this is our X array in Xa = y
    #print(xArray)
    # To solve for a (vector of coefficients), we use linear regression
    # a = ((XtX)**-1)*Xt*y
    xTxArray = xArray*np.transpose(xArray)
    a = np.linalg.inv(xTxArray)*xArray*subSeq

    # Matrix Multiplication in Numpy might need to use .dot() method. Bit confusing.
    
    print(a)
    aExtended = a.a
    predictSeq = 0
